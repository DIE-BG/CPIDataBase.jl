var documenterSearchIndex = {"docs":
[{"location":"TestHelpers/","page":"TestHelpers API","title":"TestHelpers API","text":"CurrentModule = CPIDataBase.TestHelpers","category":"page"},{"location":"TestHelpers/#TestHelpers-API","page":"TestHelpers API","title":"TestHelpers API","text":"","category":"section"},{"location":"TestHelpers/","page":"TestHelpers API","title":"TestHelpers API","text":"Funciones para pruebas del paquete. Los datos de Macronia de esta documentación son generados con estas utilidades.","category":"page"},{"location":"TestHelpers/","page":"TestHelpers API","title":"TestHelpers API","text":"getrandomweights\ngetbasedates\ngetzerobase\ngetrandombase\ngetzerocountryst\ngetrandomcountryst","category":"page"},{"location":"TestHelpers/#CPIDataBase.TestHelpers.getrandomweights","page":"TestHelpers API","title":"CPIDataBase.TestHelpers.getrandomweights","text":"getrandomweights(T=Float32, G=218)\n\nFunción para generar pesos aleatorios \n\n\n\n\n\n","category":"function"},{"location":"TestHelpers/#CPIDataBase.TestHelpers.getbasedates","page":"TestHelpers API","title":"CPIDataBase.TestHelpers.getbasedates","text":"getbasedates(vmat, startdate=Date(2000, 12))\n\nFunción para generar fechas a partir de matriz de variaciones intermensuales\n\n\n\n\n\n","category":"function"},{"location":"TestHelpers/#CPIDataBase.TestHelpers.getzerobase","page":"TestHelpers API","title":"CPIDataBase.TestHelpers.getzerobase","text":"getzerobase(; \n    [T_type = Float32, \n    G = 218, \n    T_periods = 120, \n    startdate = Date(2001,1), \n    baseindex = 100*one(T_type)])\n\nFunción para obtener base de tipo VarCPIBase con variaciones intermensuales iguales a cero.\n\n\n\n\n\n","category":"function"},{"location":"TestHelpers/#CPIDataBase.TestHelpers.getrandombase","page":"TestHelpers API","title":"CPIDataBase.TestHelpers.getrandombase","text":"getrandombase(; \n    [T_type = Float32, \n    G = 218, \n    T_periods = 120, \n    startdate = Date(2001,1), \n    baseindex = 100*one(T_type)])\n\nFunción para obtener una base de tipo VarCPIBase con variaciones intermensuales aleatorias.\n\n\n\n\n\n","category":"function"},{"location":"TestHelpers/#CPIDataBase.TestHelpers.getzerocountryst","page":"TestHelpers API","title":"CPIDataBase.TestHelpers.getzerocountryst","text":"getzerocountryst(T_type = Float32)\n\nObtiene un UniformCountryStructure cuyas variaciones intermensuales son todas iguales a cero en la configuración de períodos del IPC de Guatemala.\n\n\n\n\n\n","category":"function"},{"location":"TestHelpers/#CPIDataBase.TestHelpers.getrandomcountryst","page":"TestHelpers API","title":"CPIDataBase.TestHelpers.getrandomcountryst","text":"getrandomcountryst(T_type = Float32)\n\nObtiene un UniformCountryStructure cuyas variaciones intermensuales son todas aleatorias en la configuración de períodos del IPC de Guatemala.\n\n\n\n\n\n","category":"function"},{"location":"CPITrees/","page":"Estructura jerárquica del IPC","title":"Estructura jerárquica del IPC","text":"CurrentModule = CPIDataBase","category":"page"},{"location":"CPITrees/#Estructura-jerárquica-del-IPC","page":"Estructura jerárquica del IPC","title":"Estructura jerárquica del IPC","text":"","category":"section"},{"location":"CPITrees/","page":"Estructura jerárquica del IPC","title":"Estructura jerárquica del IPC","text":"CPITree\nGroup\nItem\ngetindex(::CPITree, ::AbstractString)\ncompute_index","category":"page"},{"location":"CPITrees/#CPIDataBase.CPITree","page":"Estructura jerárquica del IPC","title":"CPIDataBase.CPITree","text":"CPITree\n\nCPITree(base::FullCPIBase, tree::Union{Group, Item}, group_names::Vector{String}, group_codes::Vector{String})\nCPITree(; base::FullCPIBase, groupsdf::DataFrame, characters::(NTuple{N, Int} where N), upperlevel_code = \"_0\", upperlevel_name = \"IPC\")\n\nContenedor envolvente de un árbol jerárquico del IPC y los datos necesarios de los gastos básicos para computar cualquier jerarquía dentro del árbol. Permite visualizar y explorar la composición del IPC de un país, así como computar los índices de precios de las diferentes jerarquías de la estructura del IPC. Está compuesto por: \n\nUn objeto base, de tipo FullCPIBase, el cual almacena las series de tiempo de los índices de los gastos básicos. \nUn objeto tree que contiene la estructura de nodos del IPC.\nEl vector de nombres group_names de los grupos del árbol tree.\nEl vector de códigos group_codes de los grupos del árbol tree.\n\nEl constructor simple requiere una estructura jerárquica de nodos como la devuelta por get_cpi_tree. Al utilizar el constructor con groupsdf y characters, se construye automáticamente un CPITree utilizando los códigos como indicadores de la estructura jerárquica. Los códigos de los gastos básicos contenidos en base describen cómo se agrupan las jerarquías. Por ejemplo, el siguiente FullCPIBase contiene 10 gastos básicos: \n\njulia> base\nFullCPIBase{Float32, Float32}: 36 períodos × 10 gastos básicos Jan-01-Dec-03\n┌─────┬────────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐\n│ Row │      Dates │ _011101 │ _011201 │ _011202 │ _021101 │ _022101 │ _031101 │ _041101 │ _041201 │ _041202 │ _041301 │\n│     │            │  Item A │  Item B │  Item C │  Item D │  Item E │  Item F │  Item G │  Item H │  Item I │  Item J │\n│     │            │ 11.8947 │ 2.39931 │ 7.80836 │ 1.58585 │  20.141 │ 12.0526 │ 9.56901 │ 14.6256 │ 15.0276 │ 4.89602 │\n├─────┼────────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┤\n│   1 │ 2001-01-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  101.13 │  100.00 │  100.00 │  100.51 │  100.00 │\n│   2 │ 2001-02-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  102.28 │  100.00 │  100.00 │  101.02 │  100.00 │\n│   3 │ 2001-03-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  103.44 │  100.00 │  100.00 │  101.53 │  100.00 │\n│   4 │ 2001-04-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  104.61 │  100.00 │  100.00 │  102.05 │  100.00 │\n│   5 │ 2001-05-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  105.79 │  100.00 │  100.00 │  102.56 │  100.00 │\n│  ⋮  │     ⋮      │    ⋮    │    ⋮    │    ⋮    │    ⋮    │    ⋮    │    ⋮    │    ⋮    │    ⋮    │    ⋮    │    ⋮    │\n│  32 │ 2003-08-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  143.39 │  100.00 │  100.00 │  117.59 │  100.00 │\n│  33 │ 2003-09-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  145.02 │  100.00 │  100.00 │  118.19 │  100.00 │\n│  34 │ 2003-10-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  146.66 │  100.00 │  100.00 │  118.79 │  100.00 │\n│  35 │ 2003-11-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  148.32 │  100.00 │  100.00 │  119.39 │  100.00 │\n│  36 │ 2003-12-01 │  100.00 │  100.00 │  100.00 │  100.00 │  100.00 │  150.00 │  100.00 │  100.00 │  120.00 │  100.00 │\n└─────┴────────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘\n                                                                                                         26 rows omitted\n\nEn este ejemplo, el argumento debe especificarse como characters = (3, 4, 5, 7), pues los códigos indican las jerarquías en el IPC de manera siguiente: \n\nLos primeros 3 caracteres indican la jerarquía de división de gasto. \nEl siguiente caracter indica la jerarquía de agrupación de gasto. \nEl siguiente caracter indica la jerarquía de subgrupo de gasto. \nLos siguientes 2 caracteres indican el número de gasto básico dentro de su grupo. \n\nPor su parte, el DataFrame groupsdf debe tener la estructura mínima siguiente: \n\nLa primera columna debe ser de tipo String y contiene los códigos de los grupos disponibles en la estructura del IPC. \nLa segunda columna debe ser de tipo String y contiene las descripciones o\n\nnombres de los grupos disponibles en la estructura del IPC. Por ejemplo, el DataFrame groupsdf puede verse de esta forma: \n\n17×2 DataFrame\n Row │ code    description \n     │ String  String      \n─────┼─────────────────────\n   1 │ _01     Div._01\n   2 │ _02     Div._02\n   3 │ _03     Div._03\n   4 │ _04     Div._04\n   5 │ _011    Agr._011\n   6 │ _021    Agr._021\n   7 │ _022    Agr._022\n   8 │ _031    Agr._031\n   9 │ _041    Agr._041\n  10 │ _0111   Subgr._0111\n  11 │ _0112   Subgr._0112\n  12 │ _0211   Subgr._0211\n  13 │ _0221   Subgr._0221\n  14 │ _0311   Subgr._0311\n  15 │ _0411   Subgr._0411\n  16 │ _0412   Subgr._0412\n  17 │ _0413   Subgr._0413\n\nPor ejemplo, al construir un CPITree con la estructura de códigos indicada anteriormente y el DataFrame de ejemplo, el árbol del IPC se puede ver de esta forma: \n\njulia> tree = CPITree(; base, groupsdf, characters=(3,4,5,7))\nCPITree{Group{Group{Group{Group{Item{Float32}, Float32}, Float32}, Float32}, Float32}} con datos\n└─→ FullCPIBase{Float32, Float32}: 36 períodos × 10 gastos básicos Jan-01-Dec-03\n_0: IPC [100.0]\n├─ _01: Div._01 [21.491905]\n│  └─ _011: Agr._011 [21.491905]\n│     ├─ _0111: Subgr._0111 [7.352945]\n│     │  └─ _011101: Item A [7.352945]\n│     └─ _0112: Subgr._0112 [14.13896]\n│        ├─ _011201: Item B [6.7442417]\n│        └─ _011202: Item C [7.394718]\n├─ _02: Div._02 [3.0530455]\n│  ├─ _021: Agr._021 [1.1036392]\n│  │  └─ _0211: Subgr._0211 [1.1036392]\n│  │     └─ _021101: Item D [1.1036392]\n│  └─ _022: Agr._022 [1.9494063]\n│     └─ _0221: Subgr._0221 [1.9494063]\n│        └─ _022101: Item E [1.9494063]\n├─ _03: Div._03 [11.68543]\n│  └─ _031: Agr._031 [11.68543]\n│     └─ _0311: Subgr._0311 [11.68543]\n│        └─ _031101: Item F [11.68543]\n└─ _04: Div._04 [63.769615]\n   └─ _041: Agr._041 [63.769615]\n      ├─ _0411: Subgr._0411 [16.103952]\n      │  └─ _041101: Item G [16.103952]\n      ├─ _0412: Subgr._0412 [28.824577]\n      │  ├─ _041201: Item H [11.367162]\n      │  └─ _041202: Item I [17.457417]\n      └─ _0413: Subgr._0413 [18.841085]\n         └─ _041301: Item J [18.841085]\n\n\n\n\n\n","category":"type"},{"location":"CPITrees/#CPIDataBase.Group","page":"Estructura jerárquica del IPC","title":"CPIDataBase.Group","text":"Group{S,T}\n\nGroup(code, name, children::Vector{S}) where S\nGroup(code, name, children...)\n\nRepresenta un nodo de agrupación de cualquier nivel en la estructura de nodos del IPC. Puede almacenar gastos básicos u otros grupos de mayor jerarquía. Almacena el código del grupo, su nombre o descripción y su ponderación en el IPC. \n\nPosee los campos: \n\ncode: almacena el código del grupo como un String.\nname: almacena el nombre del grupo como un String.\nweight::T: almacena la ponderación del grupo como un valor flotante de tipo T.\nchildren::Vector{S}: almacena el vector de nodos \"hijos\" de la estructura. Por ejemplo, este vector podría ser un vector de elementos Item para agrupar un conjunto de gastos básicos.\n\nAunque este nodo será usualmente creado de manera automática por métodos como CPITree, se pueden crear estructuras jerárquicas manualmente. Por ejemplo, para crear un grupo: \n\njulia> a = Item(\"_011201\", \"Item B\", 6.7442417f0)\nItem{Float32}(\"_011201\", \"Item B\", 6.7442417f0)\n\njulia> b = Item(\"_011202\", \"Item C\", 7.394718f0)\nItem{Float32}(\"_011202\", \"Item C\", 7.394718f0)\n\njulia> g = Group(\"_0112\", \"Subgr._0112\", a, b)\nGroup{Item{Float32}, Float32}\n_0112: Subgr._0112 [14.13896] \n├─ _011201: Item B [6.7442417]\n└─ _011202: Item C [7.394718]\n\nVer también: Item, CPITree.\n\n\n\n\n\n","category":"type"},{"location":"CPITrees/#CPIDataBase.Item","page":"Estructura jerárquica del IPC","title":"CPIDataBase.Item","text":"Item{T}(code::String, name::String, weight::T<:AbstractFloat)\n\nRepresenta un gasto básico en la estructura de nodos del IPC. Es el nivel más bajo de la estructura. Almacena el código del gasto básico, su nombre o descripción y su ponderación en el IPC. Los datos de este nodo deben estar disponibles en algún FullCPIBase. \n\nPosee los campos: \n\ncode: que almacena el código del gasto básico como un String.\nname: que almacena el nombre del gasto básico como un String.\nweight::T: que almacena la ponderación del gasto básico como un valor flotante de tipo T.\n\nAunque este nodo será usualmente creado de manera automática por métodos como CPITree, se pueden crear estructuras jerárquicas manualmente. Por ejemplo, para crear un nodo del nivel inferior: \n\njulia> Item(\"_011101\", \"Item A\", 7.352945f0)\nItem{Float32}(\"_011101\", \"Item A\", 7.352945f0)\n\nVer también: Group, CPITree.\n\n\n\n\n\n","category":"type"},{"location":"CPITrees/#Base.getindex-Tuple{CPITree, AbstractString}","page":"Estructura jerárquica del IPC","title":"Base.getindex","text":"Base.getindex(cpitree::CPITree, code::AbstractString)\n\nEste método se utiliza para indexar el árbol jerárquico cpitree y obtener una estructura similar cuyo nodo superior sea el nodo con el código provisto code. Por ejemplo, si tenemos el siguiente árbol: \n\njulia> tree\nCPITree{Group{Group{Group{Group{Item{Float32}, Float32}, Float32}, Float32}, Float32}} con datos\n└─→ FullCPIBase{Float32, Float32}: 36 períodos × 10 gastos básicos Jan-01-Dec-03\n_0: IPC [100.0]\n├─ _01: Div._01 [21.491905]\n│  └─ _011: Agr._011 [21.491905]\n│     ├─ _0111: Subgr._0111 [7.352945]\n│     │  └─ _011101: Item A [7.352945]\n│     └─ _0112: Subgr._0112 [14.13896]\n│        ├─ _011201: Item B [6.7442417]\n│        └─ _011202: Item C [7.394718]\n├─ _02: Div._02 [3.0530455]\n│  ├─ _021: Agr._021 [1.1036392] \n│  │  └─ _0211: Subgr._0211 [1.1036392]\n│  │     └─ _021101: Item D [1.1036392]\n│  └─ _022: Agr._022 [1.9494063]\n│     └─ _0221: Subgr._0221 [1.9494063]\n│        └─ _022101: Item E [1.9494063]\n├─ _03: Div._03 [11.68543]\n│  └─ _031: Agr._031 [11.68543]\n│     └─ _0311: Subgr._0311 [11.68543]\n│        └─ _031101: Item F [11.68543]\n└─ _04: Div._04 [63.769615]\n   └─ _041: Agr._041 [63.769615]\n      ├─ _0411: Subgr._0411 [16.103952]\n      │  └─ _041101: Item G [16.103952]\n      ├─ _0412: Subgr._0412 [28.824577]\n      │  ├─ _041201: Item H [11.367162]\n      │  └─ _041202: Item I [17.457417]\n      └─ _0413: Subgr._0413 [18.841085]\n         └─ _041301: Item J [18.841085]\n\nAl indexar por un código, como _041, obtenemos una estructura similar a partir de ese nodo:\n\njulia> tree[\"_041\"]\nCPITree{Group{Group{Item{Float32}, Float32}, Float32}} con datos\n└─→ FullCPIBase{Float32, Float32}: 36 períodos × 10 gastos básicos Jan-01-Dec-03\n_041: Agr._041 [63.769615]\n├─ _0411: Subgr._0411 [16.103952]\n│  └─ _041101: Item G [16.103952] \n├─ _0412: Subgr._0412 [28.824577]\n│  ├─ _041201: Item H [11.367162]\n│  └─ _041202: Item I [17.457417]\n└─ _0413: Subgr._0413 [18.841085]\n   └─ _041301: Item J [18.841085]\n\n\n\n\n\n","category":"method"},{"location":"CPITrees/#CPIDataBase.compute_index","page":"Estructura jerárquica del IPC","title":"CPIDataBase.compute_index","text":"compute_index(cpitree::CPITree [, code::AbstractString])\n\nPermite computar el índice de precios de la jerarquía provista en code. Si se omite code, se computa la jerarquía padre de la estructura cpitree. Si el nodo no se encuentra en el árbol, devuelve nothing.\n\njulia> tree\nCPITree{Group{Group{Group{Group{Item{Float32}, Float32}, Float32}, Float32}, Float32}} con datos\n└─→ FullCPIBase{Float32, Float32}: 36 períodos × 10 gastos básicos Jan-01-Dec-03\n_0: IPC [100.0]\n├─ _01: Div._01 [21.491905]\n│  └─ _011: Agr._011 [21.491905]\n│     ├─ _0111: Subgr._0111 [7.352945]\n│     │  └─ _011101: Item A [7.352945]\n│     └─ _0112: Subgr._0112 [14.13896]\n│        ├─ _011201: Item B [6.7442417]\n│        └─ _011202: Item C [7.394718]\n├─ _02: Div._02 [3.0530455]\n│  ├─ _021: Agr._021 [1.1036392]\n│  │  └─ _0211: Subgr._0211 [1.1036392]\n│  │     └─ _021101: Item D [1.1036392]\n│  └─ _022: Agr._022 [1.9494063]\n│     └─ _0221: Subgr._0221 [1.9494063]\n│        └─ _022101: Item E [1.9494063]\n├─ _03: Div._03 [11.68543]\n│  └─ _031: Agr._031 [11.68543]\n│     └─ _0311: Subgr._0311 [11.68543]\n│        └─ _031101: Item F [11.68543]\n└─ _04: Div._04 [63.769615]\n   └─ _041: Agr._041 [63.769615]\n      ├─ _0411: Subgr._0411 [16.103952]\n      │  └─ _041101: Item G [16.103952]\n      ├─ _0412: Subgr._0412 [28.824577]\n      │  ├─ _041201: Item H [11.367162]\n      │  └─ _041202: Item I [17.457417]\n      └─ _0413: Subgr._0413 [18.841085]\n         └─ _041301: Item J [18.841085]\n\njulia> compute_index(tree, \"_041\")\n36-element Vector{Float32}:\n 100.13899\n 100.2787\n 100.41912\n 100.560234\n 100.70207\n 100.84464\n 100.98792\n   ⋮\n 104.65377\n 104.81638\n 104.97984\n 105.14412\n 105.309235\n 105.47519\n\njulia> compute_index(tree[\"_041\"])\n36-element Vector{Float32}:\n 100.13899\n 100.2787\n 100.41912\n 100.560234\n 100.70207\n 100.84464\n 100.98792\n   ⋮\n 104.65377\n 104.81638\n 104.97984\n 105.14412\n 105.309235\n 105.47519\n\njulia> a = tree[\"_041302\"]\n\njulia> a === nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"CPITrees/#Funciones-de-bajo-nivel","page":"Estructura jerárquica del IPC","title":"Funciones de bajo nivel","text":"","category":"section"},{"location":"CPITrees/","page":"Estructura jerárquica del IPC","title":"Estructura jerárquica del IPC","text":"cpi_tree_nodes\nget_cpi_tree","category":"page"},{"location":"CPITrees/#CPIDataBase.cpi_tree_nodes","page":"Estructura jerárquica del IPC","title":"CPIDataBase.cpi_tree_nodes","text":"cpi_tree_nodes(codes::Vector{<:AbstractString}; \n    characters::(NTuple{N, Int} where N), depth::Int=1, chars::Int=characters[depth], prefix::AbstractString=\"\", \n    base::FullCPIBase, \n    group_names::Vector{<:AbstractString}, \n    group_codes::Vector{<:AbstractString})\n\nConstruye y devuelve una lista de nodos a partir de la lista de códigos codes o de la especificación jerárquica de caracteres en characters. Los nombres y las ponderaciones del nivel inferior (nivel de gasto básico) son obtenidas de la estructura base. Se debe proveer el vector de códigos y nombres de todas las jerarquías superiores en la estructura de códigos en los vectores group_names y group_codes.\n\nEsta función permite crear únicamente la estructura jerárquica de nodos. Para construir de manera automática una estructura del IPC, se recomienda utilizar preferentemente CPITree.\n\nVea también: CPITree.\n\n\n\n\n\n","category":"function"},{"location":"CPITrees/#CPIDataBase.get_cpi_tree","page":"Estructura jerárquica del IPC","title":"CPIDataBase.get_cpi_tree","text":"get_cpi_tree(; \n    base::FullCPIBase, \n    group_names::Vector{<:AbstractString}, \n    group_codes::Vector{<:AbstractString}, \n    characters::(NTuple{N, Int} where N),\n    upperlevel_code = \"_0\", \n    upperlevel_name = \"IPC\")\n\nFunción superior para obtener estructura jerárquica del IPC. Devuelve el nodo superior del árbol jerárquico. Utiliza la función de más bajo nivel cpi_tree_nodes para construir los nodos del nivel más alto y hacia abajo en la estructura jerárquica. Se debe proveer el vector de códigos y nombres de todas las jerarquías superiores en la estructura de códigos en los vectores group_names y group_codes. \n\nEsta función permite crear únicamente la estructura jerárquica de nodos. Para construir de manera automática una estructura del IPC, se recomienda utilizar preferentemente CPITree.\n\nVea también: CPITree.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Introducción","title":"Introducción","text":"CurrentModule = CPIDataBase","category":"page"},{"location":"#CPIDataBase","page":"Introducción","title":"CPIDataBase","text":"","category":"section"},{"location":"","page":"Introducción","title":"Introducción","text":"Este paquete provee estructuras de datos y operaciones básicas para el análisis desagregado del Índice de Precios al Consumidor (IPC). El objetivo de este paquete es proveer una herramienta de análisis y consulta de los datos desagregados a nivel de gasto básico del IPC de cualquier país para estudios relacionados con la inflación.","category":"page"},{"location":"#Estructura-de-datos-del-IPC","page":"Introducción","title":"Estructura de datos del IPC","text":"","category":"section"},{"location":"","page":"Introducción","title":"Introducción","text":"La estructura principal de datos es un contenedor de tipo CountryStructure. Supongamos que los datos del IPC de un país ficticio, llamado Macronia, se encuentran disponibles en la constante countrydata: ","category":"page"},{"location":"","page":"Introducción","title":"Introducción","text":"using CPIDataBase\nusing CPIDataBase.TestHelpers\ncountrydata = getrandomcountryst()","category":"page"},{"location":"","page":"Introducción","title":"Introducción","text":"using CPIDataBase\n# Cargar o construir countrydata\n# (...)\ncountrydata","category":"page"},{"location":"","page":"Introducción","title":"Introducción","text":"Este contenedor posee los datos del IPC de Macronia de las últimas dos décadas. Está dividido en dos estructuras de datos denominadas VarCPIBase. Cada estructura contiene las variaciones intermensuales de los números índices de precios de los gastos básicos individuales del IPC de Macronia. A su vez, el IPC de Macronia está dividido históricamente en dos bases del IPC, cada una conlleva una  metodología diferente, con diferentes gastos básicos y ponderaciones en la canasta de consumo: ","category":"page"},{"location":"","page":"Introducción","title":"Introducción","text":"Por ejemplo, estos son los datos históricos de Macronia en la década del 2000: ","category":"page"},{"location":"","page":"Introducción","title":"Introducción","text":"countrydata[1]","category":"page"},{"location":"","page":"Introducción","title":"Introducción","text":"Y estos son los datos históricos de Macronia en la década del 2010: ","category":"page"},{"location":"","page":"Introducción","title":"Introducción","text":"countrydata[2]","category":"page"},{"location":"","page":"Introducción","title":"Introducción","text":"Vea la documentación de FullCPIBase para conocer cómo crear la estructura de datos del IPC necesaria. Los datos de un FullCPIBase pueden ser convertidos a un VarCPIBase. La estructura principal de datos de este paquete es un contenedor de tipo CountryStructure, el cual permite realizar cómputos de diferentes metodologías de inflación. ","category":"page"},{"location":"#Cómputo-del-IPC","page":"Introducción","title":"Cómputo del IPC","text":"","category":"section"},{"location":"","page":"Introducción","title":"Introducción","text":"Con la estructura countrydata es posible computar el Índice de Precios al Consumidor encadenado automáticamente entre las dos bases del IPC: ","category":"page"},{"location":"","page":"Introducción","title":"Introducción","text":"inflfn = InflationTotalCPI()\ninflfn(countrydata, CPIIndex())","category":"page"},{"location":"","page":"Introducción","title":"Introducción","text":"En este ejemplo, la variable inflfn denota una \"función de inflación\". Utilizando diferentes funciones de inflación podemos computar diferentes medidas de inflación con los datos desagregados del IPC. Por ejemplo, el siguiente código computa la variación interanual del IPC, ampliamente utilizada como una medida de inflación en las economías del mundo: ","category":"page"},{"location":"","page":"Introducción","title":"Introducción","text":"inflfn = InflationTotalCPI()\ninflfn(countrydata)","category":"page"},{"location":"API/","page":"API","title":"API","text":"CurrentModule = CPIDataBase","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"CPIDataBase","category":"page"},{"location":"API/#CPIDataBase.CPIDataBase","page":"API","title":"CPIDataBase.CPIDataBase","text":"CPIDataBase\n\nLibrería base para tipos y funcionalidad básica para manejo de los datos desagregados del IPC a nivel de república. \n\n\n\n\n\n","category":"module"},{"location":"API/#Tipos-CPIBase","page":"API","title":"Tipos CPIBase","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [CPIDataBase]\nPages = [\"CPIBase.jl\"]","category":"page"},{"location":"API/","page":"API","title":"API","text":"Modules = [CPIDataBase]\nPages = [\"CPIBase.jl\"]","category":"page"},{"location":"API/#CPIDataBase.CODETYPE","page":"API","title":"CPIDataBase.CODETYPE","text":"const CODETYPE = Union{Vector{String}, Nothing}\n\nTipos posibles para los códigos en el campo codes de un FullCPIBase.\n\n\n\n\n\n","category":"type"},{"location":"API/#CPIDataBase.DATETYPE","page":"API","title":"CPIDataBase.DATETYPE","text":"const DATETYPE = Union{StepRange{Date, Month}, Vector{Date}}\n\nTipos posibles para el campo de fechas dates de un AbstractCPIBase.\n\n\n\n\n\n","category":"type"},{"location":"API/#CPIDataBase.DESCTYPE","page":"API","title":"CPIDataBase.DESCTYPE","text":"const DESCTYPE = Union{Vector{String}, Nothing}\n\nTipos posibles para los nombres en el campo names de un FullCPIBase.\n\n\n\n\n\n","category":"type"},{"location":"API/#CPIDataBase.AbstractCPIBase","page":"API","title":"CPIDataBase.AbstractCPIBase","text":"abstract type AbstractCPIBase{T <: AbstractFloat}\n\nTipo abstracto para representar conjuntos de colecciones de datos del IPC. \n\nVea también: FullCPIBase, VarCPIBase e IndexCPIBase.\n\n\n\n\n\n","category":"type"},{"location":"API/#CPIDataBase.FullCPIBase","page":"API","title":"CPIDataBase.FullCPIBase","text":"FullCPIBase{T, B} <: AbstractCPIBase{T}\n\nFullCPIBase(ipc::Matrix{T}, v::Matrix{T}, w::Vector{T}, dates::DATETYPE, baseindex::B, codes::CODETYPE, names::DESCTYPE) where {T, B}\nFullCPIBase(df::DataFrame, gb::DataFrame)\n\nContenedor completo para datos desagregados del IPC de un país. Se representa por:\n\nMatriz de índices de precios ipc que incluye la fila con los índices del número base. \nMatriz de variaciones intermensuales v. En las filas contiene los períodos y en las columnas contiene los gastos básicos.\nVector de ponderaciones w de los gastos básicos.\nFechas correspondientes dates (por meses).\nÍndices base baseindex. \nCódigos y nombres de los gastos básicos en codes y names.\n\nEl tipo T representa el tipo de datos para representar los valores de punto flotante. El tipo B representa el tipo del campo baseindex; por ejemplo, Float32 o Vector{Float32}.\n\n\n\n\n\n","category":"type"},{"location":"API/#CPIDataBase.FullCPIBase-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"API","title":"CPIDataBase.FullCPIBase","text":"FullCPIBase(df::DataFrame, gb::DataFrame)\n\nEste método constructor devuelve una estructura FullCPIBase a partir de los DataFrames de índices de precios df y de descripción de los gastos básicos gb. \n\nEl DataFrame df posee la siguiente estructura: \nContiene en la primera columna las fechas o períodos de los datos. En las siguientes columnas, debe contener los códigos de cada una de las categorías o gastos básicos de la estructura del IPC, junto con la serie de tiempo con los índices de precios individuales. \nEn las filas del DataFrame contiene los períodos por meses. La primera fila del DataFrame se utiliza para obtener el índice base. Si el valor es el mismo para todos los gastos básicos, se tomará únicamente este valor escalar (por ejemplo 100.0 como un Float64). En algunos casos, es posible que no se disponga de la información completa, por lo que los índices base podrían ser diferentes entre sí. En este caso, baseindex almacenará el vector de índices base originales. \nUn ejemplo de cómo puede verse este DataFrame es el siguiente: \n\n121×219 DataFrame\n Row │ Date         _011111  _011121  _011131  _011141  _011142  _011151  _011152 ⋯\n     │ Date         Float64  Float64  Float64  Float64  Float64  Float64  Float64 ⋯\n─────┼─────────────────────────────────────────────────────────────────────────────\n   1 │ 2000-12-01   100.0    100.0    100.0    100.0    100.0    100.0    100.0   ⋯\n   2 │ 2001-01-01   100.55   103.23   101.66   106.47   100.36   100.0    102.57   \n   3 │ 2001-02-01   101.47   104.82   102.73   108.38   101.37   100.0    103.35   \n   4 │ 2001-03-01   101.44   107.74   104.9    103.76   101.32   100.0    104.27   \n   5 │ 2001-04-01   101.91   107.28   106.19   107.83   101.82   100.0    104.73  ⋯\n   6 │ 2001-05-01   102.77   106.12   106.9    109.16   101.81   100.0    105.21   \n   7 │ 2001-06-01   103.23   109.04   107.4    112.13   102.72   100.0    105.47   \n   8 │ 2001-07-01   104.35   112.72   107.96   117.19   105.09   100.0    105.66   \n  ⋮  │     ⋮          ⋮        ⋮        ⋮        ⋮        ⋮        ⋮        ⋮     ⋱\n 114 │ 2010-05-01   218.45   501.39   200.28   477.5    179.0    215.0    164.16  ⋯\n 115 │ 2010-06-01   219.28   503.35   203.88   476.26   180.94   214.02   164.97   \n 116 │ 2010-07-01   219.1    503.78   205.19   478.34   181.78   217.6    165.9    \n 117 │ 2010-08-01   218.52   507.45   206.87   486.72   181.51   223.76   166.46   \n 118 │ 2010-09-01   218.9    505.8    206.45   501.23   182.04   228.34   166.04  ⋯\n 119 │ 2010-10-01   219.51   504.41   205.78   504.4    182.35   221.98   166.3    \n 120 │ 2010-11-01   219.11   509.63   205.41   502.88   182.16   217.01   166.34   \n 121 │ 2010-12-01   218.79   511.38   205.09   506.04   182.14   218.63   165.99   \n                                                   211 columns and 105 rows omitted\n\nEl DataFrame gb posee la siguiente estructura: \nLa primera columna contiene los códigos de las columnas del DataFrame df. \nLa segunda columna contiene el nombre o la descripción de cada una de las categorías en las columnas de df. \nY finalmente, la tercer columna, debe contener las ponderaciones asociadas a cada una de las categorías o gastos básicos de las columnas de df.\nLos nombres de las columnas no son tomados en cuenta, solamente el orden y los tipos.\nUn ejemplo de cómo puede verse este DataFrame es el siguiente: \n\n218×3 DataFrame\n Row │ Code     GoodOrService                       Weight\n     │ String   String                              Float64     \n─────┼────────────────────────────────────────────────────────\n   1 │ _011111  Arroz                               0.483952\n   2 │ _011121  Pan                                 2.82638\n   3 │ _011131  Pastas frescas y secas              0.341395\n   4 │ _011141  Productos de tortillería            1.69133\n  ⋮  │   ⋮                     ⋮                     ⋮\n 216 │ _093111  Gastos por seguros                  0.236691\n 217 │ _093121  Gastos por servicios funerarios     0.289885\n 218 │ _094111  Gastos por servicios diversos pa…   0.151793\n                                              211 rows omitted\n\n\n\n\n\n","category":"method"},{"location":"API/#CPIDataBase.IndexCPIBase","page":"API","title":"CPIDataBase.IndexCPIBase","text":"IndexCPIBase{T, B} <: AbstractCPIBase{T}\n\nIndexCPIBase(ipc::Matrix{T}, w::Vector{T}, dates::DATETYPE, baseindex::B) where {T, B}\n\nContenedor genérico de índices de precios del IPC de un país. Se representa por:\n\nMatriz de índices de precios ipc que incluye la fila con los índices del númbero base. \nVector de ponderaciones w de los gastos básicos.\nFechas correspondientes dates (por meses).\nÍndices base baseindex. \n\nEl tipo T representa el tipo de datos para representar los valores de punto flotante. El tipo B representa el tipo del campo baseindex; por ejemplo, Float32 o Vector{Float32}.\n\n\n\n\n\n","category":"type"},{"location":"API/#CPIDataBase.IndexCPIBase-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"API","title":"CPIDataBase.IndexCPIBase","text":"IndexCPIBase(df::DataFrame, gb::DataFrame)\n\nEste constructor devuelve una estructura IndexCPIBase a partir del DataFrame  de índices de precios df, que contiene en las columnas las categorías o gastos  básicos del IPC y en las filas los períodos por meses. Las ponderaciones se obtienen  de la estructura gb, en la tercera columna de ponderaciones.\n\nPara conocer la estructura de los DataFrames necesarios, vea también: FullCPIBase.\n\n\n\n\n\n","category":"method"},{"location":"API/#CPIDataBase.VarCPIBase","page":"API","title":"CPIDataBase.VarCPIBase","text":"VarCPIBase{T, B} <: AbstractCPIBase{T}\n\nVarCPIBase(v::Matrix{T}, w::Vector{T}, dates::DATETYPE, baseindex::B) where {T, B}\n\nContenedor genérico para de variaciones intermensuales de índices de precios del IPC de un país. Se representa por:\n\nMatriz de variaciones intermensuales v. En las filas contiene los períodos y en las columnas contiene los gastos básicos.\nVector de ponderaciones w de los gastos básicos.\nFechas correspondientes dates (por meses).\nÍndices base baseindex. \n\nEste tipo es el utilizado en el contenedor de bases del IPC de un país, denominado CountryStructure, ya que con los datos de un VarCPIBase es suficiente para computar cualquier medida de inflación basada en índices de precios individuales o en un estadístico de resumen de las variaciones intermensuales (como un percentil, o una media truncada).\n\nEl tipo T representa el tipo de datos para representar los valores de punto flotante. El tipo B representa el tipo del campo baseindex; por ejemplo, Float32 o Vector{Float32}.\n\nVer también: CountryStructure, UniformCountryStructure, MixedCountryStructure\n\n\n\n\n\n","category":"type"},{"location":"API/#CPIDataBase.VarCPIBase-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"API","title":"CPIDataBase.VarCPIBase","text":"VarCPIBase(df::DataFrame, gb::DataFrame)\n\nEste constructor devuelve una estructura VarCPIBase a partir del DataFrame  de índices de precios df, que contiene en las columnas las categorías o gastos  básicos del IPC y en las filas los períodos por meses. Las ponderaciones se obtienen  de la estructura gb, en la tercera columna de ponderaciones.\n\nPara conocer la estructura de los DataFrames necesarios, vea también: FullCPIBase.\n\n\n\n\n\n","category":"method"},{"location":"API/#CPIDataBase.periods-Tuple{VarCPIBase}","page":"API","title":"CPIDataBase.periods","text":"periods(base::VarCPIBase)\n\nComputa el número de períodos (meses) en las base de variaciones intermensuales. \n\n\n\n\n\n","category":"method"},{"location":"API/#Tipos-CountryStructure","page":"API","title":"Tipos CountryStructure","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [CPIDataBase]\nPages = [\"CountryStructure.jl\"]","category":"page"},{"location":"API/","page":"API","title":"API","text":"Modules = [CPIDataBase]\nPages = [\"CountryStructure.jl\"]","category":"page"},{"location":"API/#CPIDataBase.CountryStructure","page":"API","title":"CPIDataBase.CountryStructure","text":"CountryStructure{N, T <: AbstractFloat}\n\nTipo abstracto que representa el conjunto de bases del IPC de un país.\n\n\n\n\n\n","category":"type"},{"location":"API/#CPIDataBase.MixedCountryStructure","page":"API","title":"CPIDataBase.MixedCountryStructure","text":"MixedCountryStructure{N, T} <: CountryStructure{N, T}\n\nEstructura que representa el conjunto de bases del IPC de un país,  posee el campo base, que es una tupla de la estructura VarCPIBase, cada una  con su propio tipo de índices base B. Este tipo es una colección de un tipo abstracto.\n\n\n\n\n\n","category":"type"},{"location":"API/#CPIDataBase.UniformCountryStructure","page":"API","title":"CPIDataBase.UniformCountryStructure","text":"UniformCountryStructure{N, T, B} <: CountryStructure{N, T}\n\nEstructura que representa el conjunto de bases del IPC de un país,  posee el campo base, que es una tupla de la estructura VarCPIBase. Todas las bases deben tener el mismo tipo de índice base.\n\n\n\n\n\n","category":"type"},{"location":"API/#Base.eltype-Union{Tuple{CountryStructure{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"API","title":"Base.eltype","text":"eltype(::CountryStructure{N, T})\n\nTipo de dato de punto flotante del contenedor de la estructura de país CountryStructure.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.getindex-Tuple{CountryStructure, Dates.Date, Dates.Date}","page":"API","title":"Base.getindex","text":"getindex(cst::CountryStructure, startdate::Date, finaldate::Date)\n\nDevuelve una copia del CountryStructure con las bases modificadas para tener observaciones entre las fechas indicada por startdate y finaldate.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.getindex-Tuple{CountryStructure, Dates.Date}","page":"API","title":"Base.getindex","text":"getindex(cst::CountryStructure, finaldate::Date)\n\nDevuelve una copia del CountryStructure hasta la fecha indicada por finaldate.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.getindex-Tuple{CountryStructure, Int64}","page":"API","title":"Base.getindex","text":"getindex(cst::CountryStructure, i::Int)\n\nDevuelve la base número i de un contenedor CountryStructure.\n\n\n\n\n\n","category":"method"},{"location":"API/#CPIDataBase.getunionalltype-Tuple{MixedCountryStructure}","page":"API","title":"CPIDataBase.getunionalltype","text":"getunionalltype(::MixedCountryStructure)\n\nDevuelve el tipo MixedCountryStructure. Utilizado al llamar getunionalltype sobre un CountryStructure para obtener el tipo concreto UnionAll.\n\n\n\n\n\n","category":"method"},{"location":"API/#CPIDataBase.getunionalltype-Tuple{UniformCountryStructure}","page":"API","title":"CPIDataBase.getunionalltype","text":"getunionalltype(::UniformCountryStructure)\n\nDevuelve el tipo UniformCountryStructure. Utilizado al llamar getunionalltype sobre un CountryStructure para obtener el tipo concreto UnionAll. \n\n\n\n\n\n","category":"method"},{"location":"API/#CPIDataBase.index_dates-Tuple{CountryStructure}","page":"API","title":"CPIDataBase.index_dates","text":"index_dates(cst::CountryStructure)\n\nFechas correspondientes a los números índices asociados a un CountryStructure.\n\n\n\n\n\n","category":"method"},{"location":"API/#CPIDataBase.infl_dates-Tuple{CountryStructure}","page":"API","title":"CPIDataBase.infl_dates","text":"infl_dates(cst::CountryStructure)\n\nFechas correspondientes a la trayectorias de inflación computadas a partir un CountryStructure.\n\n\n\n\n\n","category":"method"},{"location":"API/#CPIDataBase.infl_periods-Tuple{CountryStructure}","page":"API","title":"CPIDataBase.infl_periods","text":"infl_periods(cst::CountryStructure)\n\nComputa el número de períodos de inflación de la estructura de país. Corresponde al número de observaciones intermensuales menos las primeras 11 observaciones de la primera base del IPC.\n\n\n\n\n\n","category":"method"},{"location":"API/#CPIDataBase.periods-Tuple{CountryStructure}","page":"API","title":"CPIDataBase.periods","text":"periods(cst::CountryStructure)\n\nComputa el número de períodos (meses) en las bases de variaciones intermensuales de la estructura de país. \n\n\n\n\n\n","category":"method"},{"location":"API/#Tipos-y-funciones-de-inflación","page":"API","title":"Tipos y funciones de inflación","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [CPIDataBase]\nPages = [\"InflationFunction.jl\", \"CombinationFunction.jl\", \"EnsembleFunction.jl\", \"InflationTotalCPI.jl\"]","category":"page"},{"location":"API/","page":"API","title":"API","text":"Modules = [CPIDataBase]\nPages = [\"InflationFunction.jl\", \"CombinationFunction.jl\", \"EnsembleFunction.jl\", \"InflationTotalCPI.jl\"]","category":"page"},{"location":"API/#CPIDataBase.CPIIndex","page":"API","title":"CPIDataBase.CPIIndex","text":"Tipo concreto único para obtener el índice de una función de inflación\n\n\n\n\n\n","category":"type"},{"location":"API/#CPIDataBase.CPIResult","page":"API","title":"CPIDataBase.CPIResult","text":"Tipo abstracto para manejar el despacho de las funciones de inflación\n\n\n\n\n\n","category":"type"},{"location":"API/#CPIDataBase.CPIVarInterm","page":"API","title":"CPIDataBase.CPIVarInterm","text":"Tipo concreto único para obtener la variación intermensual de una función de inflación\n\n\n\n\n\n","category":"type"},{"location":"API/#CPIDataBase.InflationFunction","page":"API","title":"CPIDataBase.InflationFunction","text":"abstract type InflationFunction <: Function\n\nTipo abstracto para representar las funciones de inflación que operan sobre CountryStructure y VarCPIBase. Permiten computar la medida de ritmo inflacionario interanual, el índice de precios dado por la metodología y las variaciones intermensuales del índice de precios.\n\n\n\n\n\n","category":"type"},{"location":"API/#CPIDataBase.measure_name-Tuple{InflationFunction}","page":"API","title":"CPIDataBase.measure_name","text":"measure_name(inflfn::InflationFunction)\n\nEste método permite obtener el nombre convencional de una medida de inflación. \n\n\n\n\n\n","category":"method"},{"location":"API/#CPIDataBase.measure_tag-Tuple{InflationFunction}","page":"API","title":"CPIDataBase.measure_tag","text":"measure_tag(inflfn::InflationFunction)\n\nObtiene una etiqueta de la medida de inflación. Se puede utilizar para guardar como parámetro en archivos de resultados de evaluación.\n\n\n\n\n\n","category":"method"},{"location":"API/#CPIDataBase.num_measures-Tuple{InflationFunction}","page":"API","title":"CPIDataBase.num_measures","text":"num_measures(::InflationFunction)\n\nDevuelve la cantidad de medidas devueltas por la función de inflación. Las funciones de EnsembleFunction pueden computar varias medidas de inflación simultáneamente.\n\n\n\n\n\n","category":"method"},{"location":"API/#CPIDataBase.params-Tuple{InflationFunction}","page":"API","title":"CPIDataBase.params","text":"params(inflfn::InflationFunction)\n\nMétodo para obtener parámetros de la función de inflación. Devuelve una tupla con el conjunto de parámetros utilizado por la función de inflación inflfn. Este método debe redefinirse en las nuevas medidas de inflación si estas están parametrizadas.\n\n\n\n\n\n","category":"method"},{"location":"API/#CPIDataBase.CombinationFunction","page":"API","title":"CPIDataBase.CombinationFunction","text":"CombinationFunction{N, W} <: EnsembleInflationFunction <: InflationFunction\n\nCombinationFunction(ensemble, weights [, name, tag])\nCombinationFunction(inflfn1, inflfn2 [, ...], weights [, name, tag])\n\nFunción de inflación para computar un promedio ponderado de un conjunto de N de medidas de inflación con tipo del vector de ponderaciones W.\n\n\n\n\n\n","category":"type"},{"location":"API/#CPIDataBase.InflationCombination","page":"API","title":"CPIDataBase.InflationCombination","text":"InflationCombination <: EnsembleInflationFunction <: InflationFunction\n\nAlias para CombinationFunction.\n\n\n\n\n\n","category":"type"},{"location":"API/#CPIDataBase.components-Tuple{CombinationFunction}","page":"API","title":"CPIDataBase.components","text":"components(inflfn::CombinationFunction)\n\nDevuelve un DataFrame con las componentes de la función de combinación lineal y las ponderaciones asociadas.\n\n\n\n\n\n","category":"method"},{"location":"API/#CPIDataBase.weights-Tuple{CombinationFunction}","page":"API","title":"CPIDataBase.weights","text":"weights(combfn::CombinationFunction)\n\nDevuelve el vector de ponderaciones de una CombinationFunction.\n\n\n\n\n\n","category":"method"},{"location":"API/#CPIDataBase.EnsembleFunction","page":"API","title":"CPIDataBase.EnsembleFunction","text":"EnsembleFunction{N} <: EnsembleInflationFunction\n\nEnsembleFunction(inflfn1, inflfn2 [, ...])\n\nFunción de inflación para computar un conjunto de N de medidas de inflación simultáneamente utilizando las funciones inflfn1, inflfn2, ....\n\n\n\n\n\n","category":"type"},{"location":"API/#CPIDataBase.EnsembleInflationFunction","page":"API","title":"CPIDataBase.EnsembleInflationFunction","text":"EnsembleInflationFunction <: InflationFunction <: InflationFunction\n\nTipo abstracto para conformar conjuntos de medidas de inflación\n\n\n\n\n\n","category":"type"},{"location":"API/#CPIDataBase.InflationEnsemble","page":"API","title":"CPIDataBase.InflationEnsemble","text":"InflationEnsemble <: EnsembleInflationFunction <: InflationFunction\n\nAlias para EnsembleFunction.\n\n\n\n\n\n","category":"type"},{"location":"API/#CPIDataBase.components-Tuple{EnsembleFunction}","page":"API","title":"CPIDataBase.components","text":"components(inflfn::EnsembleFunction)\n\nDevuelve un DataFrame con las componentes del EnsembleFunction.\n\n\n\n\n\n","category":"method"},{"location":"API/#Operaciones","page":"API","title":"Operaciones","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [CPIDataBase]\nPages = [\"capitalize.jl\", \"varinterm.jl\", \"varinteran.jl\", \"utils.jl\"]","category":"page"},{"location":"API/","page":"API","title":"API","text":"Modules = [CPIDataBase]\nPages = [\"capitalize.jl\", \"varinterm.jl\", \"varinteran.jl\", \"utils.jl\"]","category":"page"},{"location":"API/#CPIDataBase.capitalize","page":"API","title":"CPIDataBase.capitalize","text":"capitalize(v::AbstractVector, base_index::Real = 100)\ncapitalize(vmat::AbstractMatrix, base_index::Real = 100)\ncapitalize(vmat::AbstractMatrix, base_index::AbstractVector)\n\nFunción para encadenar un vector o matriz con variaciones intermensuales de índices de precios v o vmat para conformar un índice de precios cuyo valor base sea base_index.\n\n\n\n\n\n","category":"function"},{"location":"API/#CPIDataBase.capitalize!","page":"API","title":"CPIDataBase.capitalize!","text":"capitalize!(idx:: AbstractVector, v::AbstractVector, base_index::Real)\ncapitalize!(vmat::AbstractMatrix, base_index = 100)\n\nFunción para encadenar un vector o matriz con variaciones intermensuales de índices de precios v o vmat para conformar un índice de precios cuyo valor base sea base_index y sea almacenado en idx o en la propia matriz vmat.\n\n\n\n\n\n","category":"function"},{"location":"API/#CPIDataBase.capitalize-Tuple{VarCPIBase}","page":"API","title":"CPIDataBase.capitalize","text":"capitalize(base::VarCPIBase)\n\nEsto devuelve una nueva instancia (copia) de tipo IndexCPIBase de un objeto VarCPIBase.\n\n\n\n\n\n","category":"method"},{"location":"API/#CPIDataBase.varinterm","page":"API","title":"CPIDataBase.varinterm","text":"varinterm(idx::AbstractVecOrMat, base_index = 100)\n\nFunción para computar un vector o una matriz de variaciones intermensuales de los índices de precios en idx, utilizando como índice base base_index en la primera observación. \n\nVer también: varinterm!\n\n\n\n\n\n","category":"function"},{"location":"API/#CPIDataBase.varinterm!","page":"API","title":"CPIDataBase.varinterm!","text":"varinterm!([v::AbstractVecOrMat, ] idx::AbstractVecOrMat, base_index = 100)\n\nFunción para computar un vector o una matriz de variaciones intermensuales de los índices de precios en idx, utilizando como índice base base_index en la primera observación. Si idx es una matriz, v es opcional y el cómputo se realiza sobre la misma matriz. Si idx es un vector, es necesario proporcionar v para realizar el cómputo.\n\nVer también: varinterm.\n\n\n\n\n\n","category":"function"},{"location":"API/#CPIDataBase.varinterm-Tuple{IndexCPIBase}","page":"API","title":"CPIDataBase.varinterm","text":"varinterm(base::IndexCPIBase)\n\nDevuelve una nueva copia de tipo VarCPIBase de un IndexCPIBase.\n\n\n\n\n\n","category":"method"},{"location":"API/#CPIDataBase.varinteran","page":"API","title":"CPIDataBase.varinteran","text":"varinteran(idx::AbstractVector, base_index::Real = 100) -> Vector{<:AbstractFloat}\nvarinteran(cpimat::AbstractMatrix, base_index::Real = 100) -> Matrix{<:AbstractFloat}\nvarinteran(cpimat::AbstractMatrix, base_index::AbstractVector) -> Matrix{<:AbstractFloat}\n\nObtiene variaciones interanuales del vector idx o de la matriz cpimat utilizando como índice base el número o vector base_index. \n\nSi base_index es un vector, se obtienen las variaciones interanuales utilizando diferentes índices base para cada columna de cpimat. El vector base_index debe tener la misma cantidad de columnas que cpimat.\n\n\n\n\n\n","category":"function"},{"location":"API/#CPIDataBase.varinteran!","page":"API","title":"CPIDataBase.varinteran!","text":"varinteran!(v::AbstractVector, idx::AbstractVector, base_index::Real = 100) -> Vector{<:AbstractFloat}\n\nComputa las variaciones interanuales del vector idx utilizando como índice base base_index. Si se provee v, los resultados son guardados en este vector, en vez del mismo idx.\n\nEl vector v tiene 11 observaciones menos que idx.\n\n\n\n\n\n","category":"function"},{"location":"API/#CPIDataBase.getdates-Tuple{Dates.Date, AbstractMatrix}","page":"API","title":"CPIDataBase.getdates","text":"getdates(startdate::Date, vmat::AbstractMatrix)\n\nObtiene un rango de fechas a partir de una fecha inicial startdate y la cantidad de períodos en la matriz de variaciones intermensuales vmat.\n\n\n\n\n\n","category":"method"},{"location":"API/#CPIDataBase.getdates-Tuple{Dates.Date, Int64}","page":"API","title":"CPIDataBase.getdates","text":"getdates(startdate::Date, periods::Int)\n\nObtiene un rango de fechas a partir de una fecha inicial startdate y la cantidad de períodos de una matriz de variaciones intermensuales \n\n\n\n\n\n","category":"method"}]
}
